#!/usr/bin/env perl
#
#
use strict;
use warnings;
use feature qw[unicode_strings switch];
use open ':encoding(utf8)';
no if $] >= 5.018, 'warnings', "experimental::smartmatch";

use Encode;
use File::Basename;
use File::Glob;
use File::Slurp;
use File::Spec;
use IO::File;
use IO::String;
use XML::Twig;
use Data::Dump;

my $request_info = {};
my $type_info    = {};
my $current_set;

# ------------------------------------------------------------------------
sub list {
    return () unless ( defined( $_[0] ) );
    return @{ $_[0] } if ( ref( $_[0] ) eq 'ARRAY' );
    return $_[0];
}

# ----------------------------------------------------------------------
sub build_pod {
    my $info = shift;
    my $twg  = shift;

    my $pod = '';
    my $out = IO::String->new($pod);
    $out->printf( "\n=head3 %s\n\n", $info->{name} );

    # extract documentation and output
    my $docelt = $twg->first_elt('xs:documentation');
    if ($docelt) {
        my $doc = $docelt->text;
        $info->{is_command} = 1 if ( $doc =~ /SuccessResponse/ );
        $doc =~ tr/\001-\176/ /cs;
        $doc =~ s/^\s{6,}//mg;
        $doc =~ s/\s+$//mg;
        $doc =~ s/^\s{,2}(?=\w)//mg;
        $doc =~ s/\s+(?=The\s+response\s+is)/\n\n/mg;
        $doc =~ s/\b(\w+[A-Z][a-z]\w+)\b/C<$1>/g;
        $out->print($doc);
    }

    # output fixed parameter info
    if ( scalar( @{ $info->{fixed_parameters} } ) ) {
        $out->print("\nFixed parameters are:-\n");
        $out->print("\n=over 4\n");
        $out->print("\n=item $_\n") foreach ( @{ $info->{fixed_parameters} } );
        $out->print("\n=back\n");
    }

    # and any additionals
    $out->print("\nAdditionally there are generic tagged parameters.\n");

    $info->{pod} = $pod;

    # end
}

# ----------------------------------------------------------------------
sub build_sub_entry {
    my $out  = shift;
    my $info = shift;

    # build fixed parameters
    my $count = 0;
    my @param_set = map { '$x' . $count++ } @{ $info->{fixed_parameters} };

    # add generics if needed
    push( @param_set, '@params' ) if ( $info->{need_generic_params} );

    # output method header with parameters
    $out->printf( "method %s\n(%s)\n{\n", $info->{name}, join( ', ', @param_set ) );

    # output command call
    $out->printf( "return \$self->send_%s('%s'", ( $info->{is_command} ? 'command' : 'query' ), $info->{name} );

    # output fixed parameters
    $count = 0;
    map { $out->printf( ", %s => \$x%d", $_, $count++ ); } @{ $info->{fixed_parameters} };

    # output generics if needed
    $out->print(", \@params") if ( $info->{need_generic_params} );

    # output tail
    $out->print(");\n}\n");
    $out->print("# ----------------------------------------------------------------------\n");
}

# ----------------------------------------------------------------------
sub generate_code_header {
    my $fh         = shift;
    my $set_name   = shift;
    my $deprecated = shift;

    $fh->printf( "package Broadworks::OCIP::%s;\n", $set_name );
    $fh->print("\n");
    $fh->printf( "# ABSTRACT: Broadworks OCI-P %s autogenerated from XML Schema\n", $set_name );
    $fh->print("\n");
    $fh->print("use strict;\n");
    $fh->print("use warnings;\n");
    $fh->print("use utf8;\n");
    $fh->print("use namespace::autoclean;\n");
    $fh->print("use Method::Signatures;\n");

    if ($deprecated) {
        $fh->print("use Moose::Role;\n");
    }
    else {
        $fh->print("use Moose;\n");
    }
    ##$fh->print("#  This file will be too big for perl critic to work well\n");
    ##$fh->print("## no critic\n");
    $fh->print("\n");
    $fh->print("# VERSION\n");
    $fh->print("# AUTHORITY\n");
    $fh->print("\n");
    $fh->print("# ----------------------------------------------------------------------\n");
    $fh->print("\n");
}

# ----------------------------------------------------------------------
sub generate_code_trailer {
    my $fh         = shift;
    my $set_name   = shift;
    my $deprecated = shift;

    $fh->print("\n");
    $fh->print("__PACKAGE__->meta->make_immutable;\n") unless ($deprecated);
    $fh->print("1;\n");
}

# ----------------------------------------------------------------------
sub generate_pod_header {
    my $fh         = shift;
    my $set_name   = shift;
    my $deprecated = shift;

    $fh->printf( "# PODNAME: Broadworks::OCIP::OCIP::%s\n",                         $set_name );
    $fh->printf( "# ABSTRACT: Broadworks OCI-P %s autogenerated from XML Schema\n", $set_name );
    $fh->print("\n");
}

# ----------------------------------------------------------------------
sub generate_pod_trailer {
    my $fh         = shift;
    my $set_name   = shift;
    my $deprecated = shift;

    $fh->print("\n");
}

# ----------------------------------------------------------------------
sub get_class_name {
    my $fn = shift;

    my ( $volume, $directories, $file ) = File::Spec->splitpath($fn);
    my $class = $file;
    $class =~ s/\..*$//;        # remove extension
    $class =~ s/OCISchema//;    # remove basename

    return $class;
}

# ----------------------------------------------------------------------
sub parse_request_info {
    my $name = shift;
    my $twg  = shift;
    my $elt  = shift;

    my $ptypes = {};
    my @fixed_parameters;
    my $res = {
        name                => $name,
        fixed_parameters    => \@fixed_parameters,
        parameter_types     => $ptypes,
        is_command          => 0,
        need_generic_params => 0
    };
    $request_info->{$name} = $res;
    $current_set->{classes}{ $current_set->{current_class} } ||= [];
    push( @{ $current_set->{classes}{ $current_set->{current_class} } }, $name );

    # parse through the parameter sets
    my $seq = $elt->first_child;    # This should be a sequence
    unless ( defined($seq) ) {
        ## no parameters at all...
    }
    elsif ( $seq->tag eq 'xs:sequence' ) {
        my @elements = $seq->children;
        while ( my $elem = shift @elements ) {
            if ( $elem->tag eq 'xs:element' ) {
                my $ename = $elem->att('name');
                my $etype = $elem->att('type');

                # deal with optional/multi params
                if ( $elem->att_exists('minOccurs') ) {
                    my $minoc = $elem->att('minOccurs');
                    $res->{need_generic_params} = 1;
                    last if ( $minoc == 0 );
                }
                push( @fixed_parameters, $ename );
                $ptypes->{$ename} = $etype;
                $ptypes->{$ename} = $etype;
                last if ( $res->{need_generic_params} );
            }
            else {
                $res->{need_generic_params} = 1;
                last;
            }
        }
    }
    elsif ( $seq->tag eq 'xs:choice' ) {
        $res->{need_generic_params} = 1;
    }
    else {
        die "Expected sequence or choice in $name\n";
    }
    build_pod( $res, $twg );
}

# ----------------------------------------------------------------------
sub complex_type_parser {
    my ( $t, $type ) = @_;

    my $name = $type->att('name');
    if ( defined($name) ) {
        my $base_elt = $t->first_elt('xs:extension[@base]');
        if ($base_elt) {
            my $base = $base_elt->att('base');
            my $i;
            given ($base) {
                when ('core:OCIRequest') { $i = 'Q'; parse_request_info( $name, $t, $base_elt ); }
                when ('core:OCIDataResponse') { $i = 'D' }
                when ('core:OCIResponse')     { $i = 'R' }
                default                       { $i = '?' }
            }
            ### print "#    $i $name\n";
        }
        else {
            ### print "#    - $name\n";
        }
    }
    $type->purge;
}

# ----------------------------------------------------------------------
sub process_file {
    my $fn      = shift;
    my $twig    = shift;
    my $dataset = shift;

    my $class_base_name = get_class_name($fn);
    warn("- $class_base_name\n");
    $dataset->{classlist} ||= [];
    push( @{ $dataset->{classlist} }, $class_base_name );
    $dataset->{current_class} = $class_base_name;

    my $xml = read_file( $fn, { binmode => ':encoding(ISO-8859-1)' } );
    $twig->parse($xml);
}

# ----------------------------------------------------------------------
sub build_twig {
    my $twig = XML::Twig->new( twig_handlers => { 'xs:complexType' => \&complex_type_parser, }, );

    return $twig;
}

# ----------------------------------------------------------------------

my $twig     = build_twig();
my $datasets = {};
while ( my $fn = shift ) {
    my $set = ( $fn =~ /Deprecated/ ) ? 'Deprecated' : 'Methods';
    $datasets->{$set} ||= {};
    $current_set = $datasets->{$set};
    process_file( $fn, $twig, $current_set );
}

# generate files
foreach my $set (qw[Methods Deprecated]) {
    my $thisset = $datasets->{$set};

    my $code = IO::File->new( $set . '.pm',  'w' ) || die "Cannot open code $set - $!";
    my $pod  = IO::File->new( $set . '.pod', 'w' ) || die "Cannot open pod $set - $!";
    generate_code_header( $code, $set, ( $set eq 'Deprecated' ) ? 1 : 0 );
    generate_pod_header( $pod, $set, ( $set eq 'Deprecated' ) ? 1 : 0 );
    foreach my $class ( @{ $thisset->{classlist} } ) {
        $code->printf("##\n## $class\n##\n");
        $pod->printf("\n=head2 $class\n\n");
        foreach my $func ( @{ $thisset->{classes}{$class} } ) {
            build_sub_entry( $code, $request_info->{$func} );
            $pod->print( $request_info->{$func}{pod} );

        }
    }

    # generate trailers and close files
    generate_code_trailer( $code, $set, ( $set eq 'Deprecated' ) ? 1 : 0 );
    generate_pod_trailer( $pod, $set, ( $set eq 'Deprecated' ) ? 1 : 0 );
    $code->close;
    $pod->close;
}

